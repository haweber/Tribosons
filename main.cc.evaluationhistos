#include "main.h"

//_______________________________________________________________________________________________________
int main(int argc, char** argv)
{

//********************************************************************************
//
// 0. Notes on global configuration classes and global TTree reader class
//
//********************************************************************************

    // 1.

    // There is a global variable defined in AnalysisConfig.cc
    //
    //   AnalysisConfig ana;
    //
    // This class instance contains configuration that persists through the entire run time.
    // (e.g. number of events, the input file name list, etc. that will not change through run time)
    // (see AnalysisConfig.h to get a feeling)

    // 2.

    // There is a global variable defined in AnalysisConfig.cc
    //
    //   InputConfig input;
    //
    // This class instance contains configuration that persists only through a single ROOT file in the chain of input ROOT files.
    // Everytime looper loads new file, the configuration in this class is reconfigured to handle sample dependent behaviors.
    // (e.g. is_data? is_sig? is_bkg? etc.)
    // (see InputConfig.h to get a feeling)

    // 3.

    // Then there is a global variable defined in wwwtree.cc
    //
    //    wwwtree www;
    //
    // This is an instance which helps read variables in the WWW baby TTree
    // It is a giant wrapper that facilitates reading TBranch values.
    // e.g. if there is a TBranch named "lep_pt" which is a std::vector<float> then, one can access the branch via
    //
    //    std::vector<float> lep_pt = www.lep_pt();
    //
    // and no need for "SetBranchAddress" and declaring variable shenanigans necessary.
    // This is a standard thing SNT does pretty much every looper we use.

    // 4.

    // The there are a few scale factor reader classes that are also globally defined
    // Those are defined in scalefactors.h
    // They are nothing more than just reading TH's from ROOT files and retrieving the contents in a simpler way

//********************************************************************************
//
// 1. Parsing options
//
//********************************************************************************

    // cxxopts is just a tool to parse argc, and argv easily

    // Grand option setting
    cxxopts::Options options("\n  $ doAnalysis",  "\n         **********************\n         *                    *\n         * Run 2 WWW Analysis *\n         *                    *\n         **********************\n");

    // Read the options
    options.add_options()
        ("i,input"       , "Comma separated input file list OR if just a directory is provided it will glob all in the directory BUT must end with '/' for the path", cxxopts::value<std::string>())
        ("T,tree"        , "Name of the TTree in the input file to loop over"                                                    , cxxopts::value<std::string>())
        ("o,output"      , "Output file name"                                                                                    , cxxopts::value<std::string>())
        ("n,nevents"     , "N events to loop over"                                                                               , cxxopts::value<int>()->default_value("-1"))
        ("t,test"        , "Run test job. i.e. overrides output option to 'test.root' and 'recreate's the file.")
        ("H,hist"        , "Book histogram")
        ("C,cutflow"     , "Book cutflows")
        ("S,systematics" , "Also consider systematics (NOTE: Generally, this limits the number of histograms and cutflows. use -f,--force to run all.)")
        ("f,force"       , "force process all and not limit any number of histograms and cutflows")
        ("F,fake"        , "The event weight will be multiplied by fake weights")
        ("u,user_study"  , "Enable user_study function for analyzers to make their own studies")
        ("j,nsplit_jobs" , "Enable splitting jobs by N blocks (--job_index must be set)", cxxopts::value<int>())
        ("I,job_index"   , "job_index of split jobs (--nsplit_jobs must be set. index starts from 0. i.e. 0, 1, 2, 3, etc...)", cxxopts::value<int>())
        ("h,help"        , "Print help")
        ;

    auto result = options.parse(argc, argv);

    // NOTE: When an option was provided (e.g. -i or --input), then the result.count("<option name>") is more than 0
    // Therefore, the option can be parsed easily by asking the condition if (result.count("<option name>");
    // That's how the several options are parsed below

    //_______________________________________________________________________________
    // --help
    if (result.count("help"))
    {
        std::cout << options.help() << std::endl;
        exit(1);
    }

    //_______________________________________________________________________________
    // --input
    if (result.count("input"))
    {
        ana.input_file_list_tstring = result["input"].as<std::string>();
    }
    else
    {
        std::cout << options.help() << std::endl;
        std::cout << "ERROR: Input list is not provided! Check your arguments" << std::endl;
        exit(1);
    }

    //_______________________________________________________________________________
    // --nevents
    ana.n_events = result["nevents"].as<int>();

    //_______________________________________________________________________________
    // --test
    if (result.count("test"))
    {
        ana.output_tfile = new TFile("test.root", "recreate");
    }
    else
    {
        //_______________________________________________________________________________
        // --output
        if (result.count("output"))
        {
            ana.output_tfile = new TFile(result["output"].as<std::string>().c_str(), "create");
            if (not ana.output_tfile->IsOpen())
            {
                std::cout << options.help() << std::endl;
                std::cout << "ERROR: output already exists! provide new output name or delete old file. OUTPUTFILE=" << result["output"].as<std::string>() << std::endl;
                exit(1);
            }
        }
        else
        {
            std::cout << options.help() << std::endl;
            std::cout << "ERROR: Output file name is not provided! Check your arguments" << std::endl;
            exit(1);
        }
    }

    //_______________________________________________________________________________
    // --tree
    if (result.count("tree"))
    {
        ana.input_tree_name = result["tree"].as<std::string>();
    }
    else
    {
        std::cout << options.help() << std::endl;
        std::cout << "ERROR: Input tree name is not provided! Check your arguments" << std::endl;
        exit(1);
    }

    //_______________________________________________________________________________
    // --hist
    if (result.count("hist"))
    {
        ana.do_histograms = true;
    }
    else
    {
        ana.do_histograms = false;
    }

    //_______________________________________________________________________________
    // --cutflow
    if (result.count("cutflow"))
    {
        ana.do_cutflow = true;
    }
    else
    {
        ana.do_cutflow = false;
    }

    //_______________________________________________________________________________
    // --systematics
    if (result.count("systematics"))
    {
        ana.do_systematics = true;
    }
    else
    {
        ana.do_systematics = false;
    }

    //_______________________________________________________________________________
    // --force
    if (result.count("force"))
    {
        ana.do_force = true;
    }
    else
    {
        ana.do_force = false;
    }

    //_______________________________________________________________________________
    // --fake
    if (result.count("fake"))
    {
        ana.do_fake_estimation = true;
    }
    else
    {
        ana.do_fake_estimation = false;
    }

    //_______________________________________________________________________________
    // --user_study
    if (result.count("user_study"))
    {
        ana.do_user_study = true;
    }
    else
    {
        ana.do_user_study = false;
    }

    //_______________________________________________________________________________
    // --nsplit_jobs
    if (result.count("nsplit_jobs"))
    {
        ana.nsplit_jobs = result["nsplit_jobs"].as<int>();
        if (ana.nsplit_jobs <= 0)
        {
            std::cout << options.help() << std::endl;
            std::cout << "ERROR: option string --nsplit_jobs" << ana.nsplit_jobs << " has zero or negative value!" << std::endl;
            std::cout << "I am not sure what this means..." << std::endl;
            exit(1);
        }
    }
    else
    {
        ana.nsplit_jobs = -1;
    }

    //_______________________________________________________________________________
    // --nsplit_jobs
    if (result.count("job_index"))
    {
        ana.job_index = result["job_index"].as<int>();
        if (ana.job_index < 0)
        {
            std::cout << options.help() << std::endl;
            std::cout << "ERROR: option string --job_index" << ana.job_index << " has negative value!" << std::endl;
            std::cout << "I am not sure what this means..." << std::endl;
            exit(1);
        }
    }
    else
    {
        ana.job_index = -1;
    }


    // Sanity check for split jobs (if one is set the other must be set too)
    if (result.count("job_index") or result.count("nsplit_jobs"))
    {
        // If one is not provided then throw error
        if ( not (result.count("job_index") and result.count("nsplit_jobs")))
        {
            std::cout << options.help() << std::endl;
            std::cout << "ERROR: option string --job_index and --nsplit_jobs must be set at the same time!" << std::endl;
            exit(1);
        }
        // If it is set then check for sanity
        else
        {
            if (ana.job_index >= ana.nsplit_jobs)
            {
                std::cout << options.help() << std::endl;
                std::cout << "ERROR: --job_index >= --nsplit_jobs ! This does not make sense..." << std::endl;
                exit(1);
            }
        }
    }

    //
    // Printing out the option settings overview
    //
    std::cout <<  "=========================================================" << std::endl;
    std::cout <<  " Setting of the analysis job based on provided arguments " << std::endl;
    std::cout <<  "---------------------------------------------------------" << std::endl;
    std::cout <<  " ana.input_file_list_tstring: " << ana.input_file_list_tstring <<  std::endl;
    std::cout <<  " ana.output_tfile: " << ana.output_tfile->GetName() <<  std::endl;
    std::cout <<  " ana.n_events: " << ana.n_events <<  std::endl;
    std::cout <<  " ana.do_cutflow: " << ana.do_cutflow <<  std::endl;
    std::cout <<  " ana.do_histograms: " << ana.do_histograms <<  std::endl;
    std::cout <<  " ana.do_systematics: " << ana.do_systematics <<  std::endl;
    std::cout <<  " ana.do_force: " << ana.do_force <<  std::endl;
    std::cout <<  " ana.do_fake_estimation: " << ana.do_fake_estimation <<  std::endl;
    std::cout <<  " ana.do_user_study: " << ana.do_user_study <<  std::endl;
    std::cout <<  " ana.nsplit_jobs: " << ana.nsplit_jobs <<  std::endl;
    std::cout <<  " ana.job_index: " << ana.job_index <<  std::endl;
    std::cout <<  "=========================================================" << std::endl;

//********************************************************************************
//
// 2. Opening input baby files
//
//********************************************************************************

    // Create the TChain that holds the TTree's of the baby ntuples
    ana.events_tchain = RooUtil::FileUtil::createTChain(ana.input_tree_name, ana.input_file_list_tstring);

    // Create a Looper object to loop over input files
    // the "www" object is defined in the wwwtree.h/cc
    // This is an instance which helps read variables in the WWW baby TTree
    // It is a giant wrapper that facilitates reading TBranch values.
    // e.g. if there is a TBranch named "lep_pt" which is a std::vector<float> then, one can access the branch via
    //
    //    std::vector<float> lep_pt = www.lep_pt();
    //
    // and no need for "SetBranchAddress" and declaring variable shenanigans necessary
    // This is a standard thing SNT does pretty much every looper we use
    ana.looper.init(ana.events_tchain, &www, ana.n_events);

//********************************************************************************
//
// Interlude... notes on RooUtil framework (This is a custom thing built by P. Chang)
//
//********************************************************************************

    // ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    // Quick tutorial on RooUtil::Cutflow object cut tree formation
    // ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    //
    // The RooUtil::Cutflow object facilitates creating a tree structure of cuts
    //
    // To add cuts to each node of the tree with cuts defined, use "addCut" or "addCutToLastActiveCut"
    // The "addCut" or "addCutToLastActiveCut" accepts three argument, <name>, and two lambda's that define the cut selection, and the weight to apply to that cut stage
    //
    // e.g. To create following cut-tree structure one does
    //
    //             (Root) <--- Always exists as soon as RooUtil::Cutflow object is created. But this is basically hidden underneath and users do not have to care
    //                |
    //            CutWeight
    //            |       |
    //     CutPreSel1    CutPreSel2
    //       |                  |
    //     CutSel1           CutSel2
    //
    //
    //   code:
    //
    //      // Create the object (Root node is created as soon as the instance is created)
    //      RooUtil::Cutflow cutflow;
    //
    //      cutflow.addCut("CutWeight"                 , <lambda> , <lambda>); // CutWeight is added below "Root"-node
    //      cutflow.addCutToLastActiveCut("CutPresel1" , <lambda> , <lambda>); // The last "active" cut is "CutWeight" since I just added that. So "CutPresel1" is added below "CutWeight"
    //      cutflow.addCutToLastActiveCut("CutSel1"    , <lambda> , <lambda>); // The last "active" cut is "CutPresel1" since I just added that. So "CutSel1" is added below "CutPresel1"
    //
    //      cutflow.getCut("CutWeight"); // By "getting" the cut object, this makes the "CutWeight" the last "active" cut.
    //      cutflow.addCutToLastActiveCut("CutPresel2" , <lambda> , <lambda>); // The last "active" cut is "CutWeight" since I "getCut" on it. So "CutPresel2" is added below "CutWeight"
    //      cutflow.addCutToLastActiveCut("CutSel2"    , <lambda> , <lambda>); // The last "active" cut is "CutPresel2" since I just added that. So "CutSel2" is added below "CutPresel1"
    //
    // (Side note: "UNITY" lambda is defined in the framework to just return 1. This so that use don't have to type [&]() {return 1;} so many times.)
    //
    // Once the cutflow is formed, create cutflow histograms can be created by calling RooUtil::Cutflow::bookCutflows())
    // This function looks through the terminating nodes of the tree structured cut tree. and creates a histogram that will fill the yields
    // For the example above, there are two terminationg nodes, "CutSel1", and "CutSel2"
    // So in this case Root::Cutflow::bookCutflows() will create two histograms. (Actually four histograms.)
    //
    //  - TH1F* type object :  CutSel1_cutflow (4 bins, with first bin labeled "Root", second bin labeled "CutWeight", third bin labeled "CutPreSel1", fourth bin labeled "CutSel1")
    //  - TH1F* type object :  CutSel2_cutflow (...)
    //  - TH1F* type object :  CutSel1_rawcutflow (...)
    //  - TH1F* type object :  CutSel2_rawcutflow (...)
    //                                ^
    //                                |
    // NOTE: There is only one underscore "_" between <CutName>_cutflow or <CutName>_rawcutflow
    //
    // And later in the loop when RooUtil::Cutflow::fill() function is called, the tree structure will be traversed through and the appropriate yields will be filled into the histograms
    //
    // After running the loop check for the histograms in the output root file

    // ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    // Quick tutorial on RooUtil::Histograms object
    // ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    //
    // The RooUtil::Histograms object facilitates book keeping histogram definitions
    // And in conjunction with RooUtil::Cutflow object, one can book same histograms across different cut stages easily without copy pasting codes many times by hand.
    //
    // The histogram addition happens in two steps.
    // 1. Defining histograms
    // 2. Booking histograms to cuts
    //
    // Histograms are defined via following functions
    //
    //      RooUtil::Histograms::addHistogram       : Typical 1D histogram (TH1F*) "Fill()" called once per event
    //      RooUtil::Histograms::addVecHistogram    : Typical 1D histogram (TH1F*) "Fill()" called multiple times per event
    //      RooUtil::Histograms::add2DHistogram     : Typical 2D histogram (TH2F*) "Fill()" called once per event
    //      RooUtil::Histograms::add2DVecHistogram  : Typical 2D histogram (TH2F*) "Fill()" called multiple times per event
    // e.g.
    //
    //    RooUtil::Histograms histograms;
    //    histograms.addHistogram   ("MllSS"    , 180 , 0. , 300. , [&]() { return www.MllSS()  ; }); // The lambda returns float
    //    histograms.addVecHistogram("AllLepPt" , 180 , 0. , 300. , [&]() { return www.lep_pt() ; }); // The lambda returns vector<float>
    //
    // The addVecHistogram will have lambda to return vector<float> and it will loop over the values and call TH1F::Fill() for each item
    //
    // To book histograms to cuts one uses
    //
    //      RooUtil::Cutflow::bookHistogramsForCut()
    //      RooUtil::Cutflow::bookHistogramsForCutAndBelow()
    //      RooUtil::Cutflow::bookHistogramsForCutAndAbove()
    //      RooUtil::Cutflow::bookHistogramsForEndCuts()
    //
    // e.g. Given a tree like the following, we can book histograms to various cuts as we want
    //
    //              Root
    //                |
    //            CutWeight
    //            |       |
    //     CutPreSel1    CutPreSel2
    //       |                  |
    //     CutSel1           CutSel2
    //
    // For example,
    //
    //    1. book a set of histograms to one cut:
    //
    //       cutflow.bookHistogramsForCut(histograms, "CutPreSel2")
    //
    //    2. book a set of histograms to a cut and below
    //
    //       cutflow.bookHistogramsForCutAndBelow(histograms, "CutWeight") // will book a set of histograms to CutWeight, CutPreSel1, CutPreSel2, CutSel1, and CutSel2
    //
    //    3. book a set of histograms to a cut and above (... useless...?)
    //
    //       cutflow.bookHistogramsForCutAndAbove(histograms, "CutPreSel2") // will book a set of histograms to CutPreSel2, CutWeight (nothing happens to Root node)
    //
    //    4. book a set of histograms to a terminating nodes
    //
    //       cutflow.bookHistogramsForEndCuts(histograms) // will book a set of histograms to CutSel1 and CutSel2
    //
    // The naming convention of the booked histograms are as follows
    //
    //   cutflow.bookHistogramsForCut(histograms, "CutSel1");
    //
    //  - TH1F* type object : CutSel1__MllSS;
    //  - TH1F* type object : CutSel1__AllLepPt;
    //                               ^^
    //                               ||
    // NOTE: There are two underscores "__" between <CutName>__<HistogramName>
    //
    // And later in the loop when RooUtil::CutName::fill() function is called, the tree structure will be traversed through and the appropriate histograms will be filled with appropriate variables
    // After running the loop check for the histograms in the output root file

//********************************************************************************
//
// 3. Defining histograms
//
//********************************************************************************

    // The RooUtil::Histograms class holds the definitions of histograms with the lambda expression for the variable
    // Then this is used in conjunction with RooUtil::Cutflow to book histograms at different cut stage
    // This is so that the users don't have to copy paste a thousands lines of codes if they want to book more histograms at different cut stages

    ana.histograms.addVecHistogram("Cuts0SFOS",  3853, -1.5,  3851.5, []() {
        std::vector<float> filledbins; filledbins.clear();
        if(www.lep_pt().size()<3) return filledbins;
        if(www.lep_pt()[0]<=25.)  return filledbins;
        if(www.lep_pt()[2]<=20.)  return filledbins;//just to be safe
        if(www.nb()>=1)           return filledbins;
        if (not (www.Mll3L() > 20.             )) return filledbins;
        if (not (abs(www.M3l()-91.1876) > 10.  )) return filledbins;
        if (not (abs(www.Mee3L()-91.1876) > 20.)) return filledbins;
        if(www.met_pt()<=30)      return filledbins;
        float MTmin = 9e5;
        for(unsigned int i = 0; i<www.lep_p4().size(); ++i){
          float phi1 = www.lep_p4()[i].Phi();
          float phi2 = www.met_phi();
          float Et1  = www.lep_p4()[i].Et();
          float Et2  = www.met_pt();
          float MT = float(sqrt(2*Et1*Et2*(1.0 - cos(phi1-phi2))));
          if(MT<MTmin) MTmin = MT;
        }
        float DPhimin = 9e5;
        LV metlv = RooUtil::Calc::getLV(www.met_pt(),0,www.met_phi(),0);
        for(unsigned int i = 0; i<www.lep_p4().size(); ++i){
          float DPhitemp = fabs(RooUtil::Calc::DeltaPhi(www.lep_p4()[i], metlv));
          if(DPhitemp<DPhimin) DPhimin = DPhitemp;
        }                  
        std::vector<int> vlpt;vlpt.clear();
        vlpt.push_back(0);
        if(www.lep_pt()[2]>25.) vlpt.push_back(1);
        if(www.lep_pt()[2]>30.) vlpt.push_back(2);
        std::vector<int> vnj;vnj.clear();
        if(www.nj()  <=1) vnj.push_back(0);
        if(www.nj()  ==0) vnj.push_back(1);
        if(www.nj30()<=1) vnj.push_back(2);
        if(www.nj30()==0) vnj.push_back(3);
        std::vector<int> vmt;vmt.clear();
        vmt.push_back(0);
        if(www.MTmax3L()>90.)  vmt.push_back(1);
        if(www.MTmax3L()>120.) vmt.push_back(2);
        if(MTmin>30.)          vmt.push_back(3);
        if(MTmin>50.)          vmt.push_back(4);
        std::vector<int> vpt3;vpt3.clear();
        vpt3.push_back(0);
        if(www.Pt3l()>30.) vpt3.push_back(1);
        if(www.Pt3l()>50.) vpt3.push_back(2);
        if(www.Pt3l()>60.) vpt3.push_back(3);
        std::vector<int> vdl;vdl.clear();
        vdl.push_back(0);
        if(DPhimin> 0.5) vdl.push_back(1);
        if(DPhimin>0.75) vdl.push_back(2);
        if(DPhimin> 1.0) vdl.push_back(3);
        std::vector<int> vd3;vd3.clear();
        vd3.push_back(0);
        if(www.DPhi3lMET()> 2.1) vd3.push_back(1);
        if(www.DPhi3lMET()> 2.5) vd3.push_back(2);
        if(www.DPhi3lMET()> 2.7) vd3.push_back(3);
        for(unsigned int ilpt = 0; ilpt<vlpt.size();++ilpt){
          for(unsigned int inj = 0; inj<vnj.size();++inj){
            for(unsigned int imt = 0; imt<vmt.size();++imt){
              for(unsigned int ipt3 = 0; ipt3<vpt3.size();++ipt3){
                for(unsigned int idl = 0; idl<vdl.size();++idl){
                  for(unsigned int id3 = 0; id3<vd3.size();++id3){
                    filledbins.push_back(vlpt[ilpt]+3*vnj[inj]+12*vmt[imt]+60*vpt3[ipt3]+240*vdl[idl]+960*vd3[id3]);
                  }
                }
              }
            }
          }
        }
        return filledbins;
      }
      );
    ana.histograms.addVecHistogram("Cuts1SFOS",  92163, -1.5,  92161.5, []() {
        std::vector<float> filledbins; filledbins.clear();
        if(www.lep_pt().size()<3) return filledbins;
        if(www.lep_pt()[0]<=25.)  return filledbins;
        if(www.lep_pt()[2]<=20.)  return filledbins;//just to be safe
        if(www.nb()>=1)           return filledbins;
        if(www.nSFOSinZ()>=1)     return filledbins;
        if (not (www.Mll3L() > 20.             )) return filledbins;
        if (not (abs(www.M3l()-91.1876) > 10.  )) return filledbins;
        if (www.nSFOS()==2 && www.Mll3L1()<20.)   return filledbins;
        if(www.met_pt()<=30)      return filledbins;
        float MTmin = 9e5;//use this if nSFOS!=1
        for(unsigned int i = 0; i<www.lep_p4().size(); ++i){
          float phi1 = www.lep_p4()[i].Phi();
          float phi2 = www.met_phi();
          float Et1  = www.lep_p4()[i].Et();
          float Et2  = www.met_pt();
          float MT = float(sqrt(2*Et1*Et2*(1.0 - cos(phi1-phi2))));
          if(MT<MTmin) MTmin = MT;
        }
        float DPhimin = 9e5;
        LV metlv = RooUtil::Calc::getLV(www.met_pt(),0,www.met_phi(),0);
        for(unsigned int i = 0; i<www.lep_p4().size(); ++i){
          float DPhitemp = fabs(RooUtil::Calc::DeltaPhi(www.lep_p4()[i], metlv));
          if(DPhitemp<DPhimin) DPhimin = DPhitemp;
        }
        std::vector<int> vlpt;vlpt.clear();
        vlpt.push_back(0);
        if(www.lep_pt()[2]>25.) vlpt.push_back(1);
        if(www.lep_pt()[2]>30.) vlpt.push_back(2);
        std::vector<int> vpt1;vpt1.clear();
        vpt1.push_back(0);
        if(www.lep_pt()[0]>30.) vpt1.push_back(1);
        if(www.lep_pt()[0]>50.) vpt1.push_back(2);
        if(www.lep_pt()[0]>90.) vpt1.push_back(3);
        std::vector<int> vnj;vnj.clear();
        if(www.nj()  <=1) vnj.push_back(0);
        if(www.nj()  >=0) vnj.push_back(1);
        if(www.nj30()<=1) vnj.push_back(2);
        if(www.nj30()==0) vnj.push_back(3);
        std::vector<int> vmt;vmt.clear();
        vmt.push_back(0);
        if(www.nSFOS()==1){
          if(www.MT3rd()>90.)  vmt.push_back(1);
          if(www.MT3rd()>120.) vmt.push_back(2);
          if(www.MT3rd()>150.) vmt.push_back(3);
        } else {
          if(www.MTmax3L()>90.) vmt.push_back(1);
          if(MTmin>30.)         vmt.push_back(2);
          if(MTmin>50.)         vmt.push_back(3);
        }
        std::vector<int> vmet;vmet.clear();
        vmet.push_back(0);
        if(www.met_pt()>45.) vmet.push_back(1);
        if(www.met_pt()>60.) vmet.push_back(2);
        if(www.met_pt()>75.) vmet.push_back(3);
        std::vector<int> vpt3;vpt3.clear();
        vpt3.push_back(0);
        if(www.Pt3l()>30.)  vpt3.push_back(1);
        if(www.Pt3l()>50.)  vpt3.push_back(2);
        if(www.Pt3l()>60.)  vpt3.push_back(3);
        if(www.Pt3l()>75.)  vpt3.push_back(4);
        if(www.Pt3l()>100.) vpt3.push_back(5);
        std::vector<int> vdl;vdl.clear();
        vdl.push_back(0);
        if(DPhimin> 0.5) vdl.push_back(1);
        if(DPhimin>0.75) vdl.push_back(2);
        if(DPhimin> 1.0) vdl.push_back(3);
        std::vector<int> vd3;vd3.clear();
        vd3.push_back(0);
        if(www.DPhi3lMET()> 2.1) vd3.push_back(1);
        if(www.DPhi3lMET()> 2.5) vd3.push_back(2);
        if(www.DPhi3lMET()> 2.7) vd3.push_back(3);
        if(www.DPhi3lMET()> 2.9) vd3.push_back(4);
        for(unsigned int ilpt = 0; ilpt<vlpt.size();++ilpt){
          for(unsigned int ipt1 = 0; ipt1<vpt1.size();++ipt1){
            for(unsigned int inj = 0; inj<vnj.size();++inj){
              for(unsigned int imt = 0; imt<vmt.size();++imt){
                for(unsigned int imet = 0; imet<vmet.size();++imet){
                  for(unsigned int ipt3 = 0; ipt3<vpt3.size();++ipt3){
                    for(unsigned int idl = 0; idl<vdl.size();++idl){
                      for(unsigned int id3 = 0; id3<vd3.size();++id3){
                        filledbins.push_back(vlpt[ilpt]+3*vpt1[ipt1]+12*vnj[inj]+48*vmt[imt]+192*vmet[imet]+768*vpt3[ipt3]+4608*vdl[idl]+18432*vd3[id3]);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return filledbins;
      }
      );
    ana.histograms.addVecHistogram("CutsSS",  114051, -1.5,  114049.5, []() { 
        std::vector<float> filledbins; filledbins.clear();
        if(www.lep_pt().size()<2) return filledbins;
        if(www.lep_pt()[1]<=25.)  return filledbins;//just to be safe
        if(www.nb()>=1)           return filledbins;
        if(www.nj30()<2)          return filledbins;
        if(www.MllSS()<=40.)      return filledbins;
        if(www.MjjL()>=500.)      return filledbins;
        if(www.DetajjL()>=2.5)    return filledbins;
        if(www.passSSee()&& fabs(www.MllSS()-91.1876) < 10.) return filledbins;
        float DPhimax = -9e5;
        LV metlv = RooUtil::Calc::getLV(www.met_pt(),0,www.met_phi(),0);
        for(unsigned int i = 0; i<www.lep_p4().size(); ++i){
          float DPhitemp = fabs(RooUtil::Calc::DeltaPhi(www.lep_p4()[i], metlv));
          if(DPhitemp>DPhimax) DPhimax = DPhitemp;
        }
        float drlj0 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[0], www.jets_p4()[0]));
        float drlj1 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[1], www.jets_p4()[0]));
        float drljj0 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[0], www.jets_p4()[1]));
        float drljj1 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[1], www.jets_p4()[1]));
        float dRljminPC = drlj0 < drlj1 ? drlj0 : drlj1;
        float dRljjminPC = drljj0 < drljj1 ? drljj0 : drljj1;
        float dRljminJJ = dRljminPC < dRljjminPC ? dRljminPC : dRljjminPC;
        float mlj0 = (www.lep_p4()[0] + www.jets_p4()[0]).mass();
        float mlj1 = (www.lep_p4()[1] + www.jets_p4()[0]).mass();
        float mljj0 = (www.lep_p4()[0] + www.jets_p4()[1]).mass();
        float mljj1 = (www.lep_p4()[1] + www.jets_p4()[1]).mass();
        float MljminPC = mlj0 < mlj1 ? mlj0 : mlj1;
        float MljjminPC = mljj0 < mljj1 ? mljj0 : mljj1;
        float MljminJJ = MljminPC < MljjminPC ? MljminPC : MljjminPC;
        float Mljmin = 9e5;
        float minDR = 9e5; float MljclDR = 9e5;
        for(unsigned int i = 0; i<www.lep_p4().size(); ++i){
          for(unsigned int j = 0; j<www.jets_p4().size(); ++j){
            float DRtemp = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[i], www.jets_p4()[j]));
            float Mlj = (www.lep_p4()[i] + www.jets_p4()[j]).M();
            if(DRtemp<minDR){ minDR = DRtemp; MljclDR = Mlj; }
            if(Mlj < Mljmin) Mljmin = Mlj;
          }
        }
        int idx1 = -1; int idx2 = -1; float minDRjj=9e5;
        for(unsigned int i = 0; i<www.jets_p4().size(); ++i){
          for(unsigned int j = i+1; j<www.jets_p4().size(); ++j){
            float DRtemp = fabs(RooUtil::Calc::DeltaR(www.jets_p4()[i], www.jets_p4()[j]));
            if(DRtemp<minDRjj){ minDRjj = DRtemp; idx1 = i; idx1 = j; }
          }
        }
        float xdrlj0 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[0], www.jets_p4()[idx1]));
        float xdrlj1 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[1], www.jets_p4()[idx1]));
        float xdrljj0 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[0], www.jets_p4()[idx2]));
        float xdrljj1 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[1], www.jets_p4()[idx2]));
        float xdRljminPC = xdrlj0 < xdrlj1 ? xdrlj0 : xdrlj1;
        float xdRljjminPC = xdrljj0 < xdrljj1 ? xdrljj0 : xdrljj1;
        float minDRljjj = xdRljminPC < xdRljjminPC ? xdRljminPC : xdRljjminPC;
        float xmlj0 = (www.lep_p4()[0] + www.jets_p4()[idx1]).mass();
        float xmlj1 = (www.lep_p4()[1] + www.jets_p4()[idx1]).mass();
        float xmljj0 = (www.lep_p4()[0] + www.jets_p4()[idx2]).mass();
        float xmljj1 = (www.lep_p4()[1] + www.jets_p4()[idx2]).mass();
        float xMljminPC = xmlj0 < xmlj1 ? xmlj0 : xmlj1;
        float xMljjminPC = xmljj0 < xmljj1 ? xmljj0 : xmljj1;
        float minMljjj = xMljminPC < xMljjminPC ? xMljminPC : xMljjminPC;
        
        float ptll = (www.lep_p4()[0] + www.lep_p4()[1]).Pt();
        std::vector<int> vlpt;vlpt.clear();
        vlpt.push_back(0);
        if(www.lep_pt()[0]>30.) vlpt.push_back(1);
        if(www.lep_pt()[0]>50.) vlpt.push_back(2);
        if(www.lep_pt()[0]>75.) vlpt.push_back(3);
        std::vector<int> vmt;vmt.clear();
        vmt.push_back(0);
        if(www.MTmax()>90.)  vmt.push_back(1);  
        if(www.MTmax()>120.) vmt.push_back(2);  
        std::vector<int> vmet;vmet.clear();
        vmet.push_back(0);
        if(www.met_pt()>30.)  vmet.push_back(1);        
        if(www.met_pt()>60.)  vmet.push_back(2);        
        if(www.met_pt()>100.) vmet.push_back(3);        
        std::vector<int> vmll;vmll.clear();
        vmll.push_back(0);
        if(www.MllSS()>100.) vmll.push_back(1);              
        std::vector<int> vmlj;vmlj.clear();
        vmlj.push_back(0); 
        if(Mljmin   < 50.) vmlj.push_back(1);     
        if(Mljmin   < 75.) vmlj.push_back(2);     
        if(Mljmin   < 90.) vmlj.push_back(3);     
        if(MljclDR  < 60.) vmlj.push_back(4);     
        if(MljclDR  < 75.) vmlj.push_back(5);                
        if(MljclDR  < 90.) vmlj.push_back(6);     
        if(minMljjj < 75.) vmlj.push_back(7);     
        if(minMljjj < 90.) vmlj.push_back(8);     
        if(MljminJJ < 75.) vmlj.push_back(9);     
        if(MljminJJ < 90.) vmlj.push_back(10);                
        std::vector<int> vdrlj;vdrlj.clear();
        vdrlj.push_back(0);
        if(dRljminPC < 1.5) vdrlj.push_back(1);
        if(dRljminPC < 2.0) vdrlj.push_back(2);
        if(minDR <     1.5) vdrlj.push_back(3);
        if(minDR <     2.0) vdrlj.push_back(4);
        if(minDRljjj < 1.5) vdrlj.push_back(5);
        if(minDRljjj < 2.0) vdrlj.push_back(6);
        if(dRljminJJ < 1.5) vdrlj.push_back(7);
        if(dRljminJJ < 2.0) vdrlj.push_back(8);
        std::vector<int> vptll;vptll.clear();
        vptll.push_back(0);
        if(ptll < 75.) vptll.push_back(1);
        if(ptll <100.) vptll.push_back(2);
        std::vector<int> vdl;vdl.clear();
        vdl.push_back(0);
        if(DPhimax>1.6) vdl.push_back(1);
        if(DPhimax>2.1) vdl.push_back(2);
        if(DPhimax>2.5) vdl.push_back(3);
        for(unsigned int ilpt = 0; ilpt<vlpt.size();++ilpt){
          for(unsigned int imt = 0; imt<vmt.size();++imt){
            for(unsigned int imet = 0; imet<vmet.size();++imet){
              for(unsigned int imll = 0; imll<vmll.size();++imll){
                for(unsigned int imlj = 0; imlj<vmlj.size();++imlj){
                  for(unsigned int idrlj = 0; idrlj<vdrlj.size();++idrlj){
                    for(unsigned int iptll = 0; iptll<vptll.size();++iptll){
                      for(unsigned int idl = 0; idl<vdl.size();++idl){
                        filledbins.push_back(vlpt[ilpt]+4*vmt[imt]+12*vmet[imet]+48*vmll[imll]+96*vmlj[imlj]+1056*vdrlj[idrlj]+9504*vptll[iptll]+28512*vdl[idl]);
                      }
                    }
                  }
                }
              }
            }
          }
        }
          
        return filledbins;
      }
      );

    ana.histograms.addVecHistogram("Cuts1JSS",  345603, -1.5,  345601.5, []() {
        std::vector<float> filledbins; filledbins.clear();
        if(www.lep_pt().size()<2) return filledbins;
        if(www.lep_pt()[1]<=25.)  return filledbins;//just to be safe
        if(www.nb()>=1)           return filledbins;
        if(www.nj30()!=1)         return filledbins;
        if(www.MllSS()<=20.)      return filledbins;
        if(www.passSSee()&& fabs(www.MllSS()-91.1876) < 10.) return filledbins;
        float DPhimax = -9e5;
        LV metlv = RooUtil::Calc::getLV(www.met_pt(),0,www.met_phi(),0);
        for(unsigned int i = 0; i<www.lep_p4().size(); ++i){
          float DPhitemp = fabs(RooUtil::Calc::DeltaPhi(www.lep_p4()[i], metlv));
          if(DPhitemp>DPhimax) DPhimax = DPhitemp;
        }
        float drlj0 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[0], www.jets_p4()[0]));
        float drlj1 = fabs(RooUtil::Calc::DeltaR(www.lep_p4()[1], www.jets_p4()[0]));
        float dRljmin = drlj0 < drlj1 ? drlj0 : drlj1;
        float mlj0 = (www.lep_p4()[0] + www.jets_p4()[0]).mass();
        float mlj1 = (www.lep_p4()[1] + www.jets_p4()[0]+www.jets_p4()[0]).mass();
        float Mljmin = mlj0 < mlj1 ? mlj0 : mlj1;

        float ptll = (www.lep_p4()[0] + www.lep_p4()[1]).Pt();
        float ptllj = (www.lep_p4()[0] + www.lep_p4()[1]).Pt();
        float MTj = sqrt(2*www.met_pt()* www.jets_p4()[0].Et()*(1.0 - cos(www.jets_p4()[0].Phi()-www.met_phi())));
        std::vector<int> vlpt;vlpt.clear();
        vlpt.push_back(0);
        if(www.lep_pt()[1]>30.) vlpt.push_back(1);  
        std::vector<int> vmet;vmet.clear();
        vmet.push_back(0);
        if(www.met_pt()>40.)  vmet.push_back(1);        
        if(www.met_pt()>60.)  vmet.push_back(2);        
        if(www.met_pt()>75.)  vmet.push_back(3);    
        std::vector<int> vmll;vmll.clear();
        vmll.push_back(0);
        if(www.MllSS()>40.) vmll.push_back(1);   
        if(www.MllSS()>60.) vmll.push_back(2);   
        std::vector<int> vmt;vmt.clear();
        vmt.push_back(0);
        if(www.MTmax()>90.)  vmt.push_back(1);  
        if(www.MTmax()>120.) vmt.push_back(2);      
        if(www.MTmin()>50.)  vmt.push_back(3);  
        if(www.MTmin()>90.)  vmt.push_back(4);
        std::vector<int> vdl;vdl.clear();
        vdl.push_back(0);
        if(DPhimax>1.6) vdl.push_back(1);
        if(DPhimax>2.1) vdl.push_back(2);            
        std::vector<int> vdrlj;vdrlj.clear();
        vdrlj.push_back(0);
        if(dRljmin <0.75) vdrlj.push_back(1);
        if(dRljmin < 1.0) vdrlj.push_back(2);
        if(dRljmin < 1.5) vdrlj.push_back(3);
        if(dRljmin < 2.1) vdrlj.push_back(4);
        if(dRljmin < 1.0 && dRljmin>0.3) vdrlj.push_back(5);
        if(dRljmin < 1.5 && dRljmin>0.3) vdrlj.push_back(6);
        if(dRljmin < 2.1 && dRljmin>0.3) vdrlj.push_back(7);
        std::vector<int> vmlj;vmlj.clear();
        vmlj.push_back(0); 
        if(Mljmin   < 50.) vmlj.push_back(1);     
        if(Mljmin   < 60.) vmlj.push_back(2);     
        if(Mljmin   < 75.) vmlj.push_back(3);     
        if(Mljmin   <100.) vmlj.push_back(4);       
        if(Mljmin   < 60. && Mljmin>20.) vmlj.push_back(5);     
        if(Mljmin   < 75. && Mljmin>20.) vmlj.push_back(6);     
        if(Mljmin   <100. && Mljmin>20.) vmlj.push_back(7);   
        std::vector<int> vptll;vptll.clear();
        vptll.push_back(0);
        if(ptll < 75.) vptll.push_back(1);
        if(ptll <100.) vptll.push_back(2);
        std::vector<int> vptllj;vptllj.clear();
        vptllj.push_back(0);
        if(ptllj > 60.) vptllj.push_back(1);
        if(ptllj > 75.) vptllj.push_back(2);
        if(MTj   > 60.) vptllj.push_back(3);
        if(MTj   > 90.) vptllj.push_back(4);
        
        for(unsigned int ilpt = 0; ilpt<vlpt.size();++ilpt){
          for(unsigned int imet = 0; imet<vmet.size();++imet){
            for(unsigned int imll = 0; imll<vmll.size();++imll){
              for(unsigned int imt = 0; imt<vmt.size();++imt){
                for(unsigned int idl = 0; idl<vdl.size();++idl){
                  for(unsigned int idrlj = 0; idrlj<vdrlj.size();++idrlj){
                    for(unsigned int imlj = 0; imlj<vmlj.size();++imlj){
                      for(unsigned int iptll = 0; iptll<vptll.size();++iptll){
                        for(unsigned int iptllj = 0; iptllj<vptllj.size();++iptllj){
                          filledbins.push_back(vlpt[ilpt]+2*vmet[imet]+8*vmll[imll]+24*vmt[imt]+120*vdl[idl]+360*vdrlj[idrlj]+2880*vmlj[imlj]+23040*vptll[iptll]+69120*vptllj[iptllj]);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
          
        return filledbins;
      }
      );

//********************************************************************************
//
// 4. Creating the analysis using RooUtil::Cutflow class
//
//********************************************************************************

    // Set the cutflow object output file
    ana.cutflow.setTFile(ana.output_tfile);

    //_______________________________________________________________________________
    //
    // Create cut tree structure
    //_______________________________________________________________________________

    // NOTE: All of the functions that are being called under namespace "Lambdas" are defined in lambdas.cc

    // Event Weights
    // At this stage of the cut, we're passing every event and just setting the event weights
    ana.cutflow.addCut("CutWeight", UNITY,              Lambdas::EventWeight);
    //                              ^^^^^               ^^^^^^^^^^^^^^^^^^^^
    //                           Pass all events        apply event weights (see lambdas.cc)

    // Preliminary selections
    ana.cutflow.addCutToLastActiveCut("CutPreliminary", Lambdas::PreliminarySelection, UNITY);

    // Trigger selection
    ana.cutflow.addCutToLastActiveCut("CutTrigger", Lambdas::TriggerSelection, Lambdas::TriggerScaleFactor);
    //===================
    // N lep requirements
    //===================
    // Now adding various lepton channel categorizations based on number of veto/loose/tight leptons
    // The lepton counters are "nVlep", "nLlep", "nTlep" for (veto, loose, tight)
    // Depending on the input.baby_type the loose may have different pt thresholds (cf. https://github.com/cmstas/VVVBabyMaker/blob/866347c30f4f880031e67534563e5e5e379b98cb/dilepbabymaker/ScanChain_v2.cc#L2375)
    // So it is safer to always require proper pt cuts on each leptons, even if it may be redundant

    // Dilep selection for signal region plots
    ana.cutflow.getCut("CutTrigger"); // Retrieve the CutTrigger and add CutSRDilep to the CutTrigger node
    ana.cutflow.addCutToLastActiveCut("CutSRDilep", Lambdas::CutSRDilep, Lambdas::LeptonScaleFactor);
    ana.cutflow.addCutToLastActiveCut("SRSSPreSel"     , Lambdas::SSPreSelection  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
    ana.cutflow.addCutToLastActiveCut("SRSSNj2"        , Lambdas::TwoCenJet30     (Variation::JES, Variation::Nominal), UNITY);
    ana.cutflow.addCutToLastActiveCut("SRSSPreselMjjIn", Lambdas::MjjIn           (Variation::JES, Variation::Nominal), UNITY);
    ana.cutflow.getCut("SRSSNj2");
    ana.cutflow.addCutToLastActiveCut("SRSSPreselMjjOut",Lambdas::MjjOut          (Variation::JES, Variation::Nominal), UNITY);

    // Trilep selection for signal region plots
    ana.cutflow.getCut("CutTrigger"); // Retrieve the CutTrigger and add CutSRTrilep to the CutTrigger node
    ana.cutflow.addCutToLastActiveCut("CutSRTrilep", Lambdas::CutSRTrilep, Lambdas::LeptonScaleFactor);
    ana.cutflow.addCutToLastActiveCut("SR3lPreSel"    , Lambdas::ThreeLepPresel  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
    ana.cutflow.addCutToLastActiveCut("SR3lDYVeto"    , Lambdas::DYVetoes1SFOS                                       , UNITY);
    ana.cutflow.addCutToLastActiveCut("SR3lZVeto"     , Lambdas::ZVeto3L                                             , UNITY);

    
    auto nominal_analysis = [&]()
    {
        //************************************************************************************************************************************************************************************************
        //
        //
        // SIGNAL REGION CUTS
        //
        //
        //************************************************************************************************************************************************************************************************

        ana.cutflow.getCut("CutSRDilep");
        ana.cutflow.addCutToLastActiveCut("SRSSee"           , Lambdas::isSRSSeeChannel                                     , UNITY);
        ana.cutflow.addCutToLastActiveCut("SRSSeeZVeto"      , Lambdas::ZVetoSS                                             , UNITY);
        ana.cutflow.addCutToLastActiveCut("SRSSeePreSel"     , Lambdas::SSPreSelection  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
        ana.cutflow.addCutToLastActiveCut("SRSSeeNj2"        , Lambdas::TwoCenJet30     (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.addCutToLastActiveCut("SRSSeePreselMjjIn", Lambdas::MjjIn           (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.getCut("SRSSeeNj2");
        ana.cutflow.addCutToLastActiveCut("SRSSeePreselMjjOut",Lambdas::MjjOut          (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSeeKinSel"     , Lambdas::SRSSeeSelection (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSeeLowDetajj"  , Lambdas::LowDEtajj       (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSeeLowMjj"     , Lambdas::LowMjj          (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSeeMjjIn"      , Lambdas::MjjIn           (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.getCut("SRSSeeLowMjj");
        ////ana.cutflow.addCutToLastActiveCut("SRSSSideeeMjjOut" , Lambdas::MjjOut          (Variation::JES, Variation::Nominal), UNITY);

        ana.cutflow.getCut("CutSRDilep");
        ana.cutflow.addCutToLastActiveCut("SRSSem"           , Lambdas::isSRSSemChannel                                     , UNITY);
        ana.cutflow.addCutToLastActiveCut("SRSSemPreSel"     , Lambdas::SSPreSelection  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
        ana.cutflow.addCutToLastActiveCut("SRSSemNj2"        , Lambdas::TwoCenJet30     (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.addCutToLastActiveCut("SRSSemPreselMjjIn", Lambdas::MjjIn           (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.getCut("SRSSemNj2");
        ana.cutflow.addCutToLastActiveCut("SRSSemPreselMjjOut",Lambdas::MjjOut          (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSemKinSel"     , Lambdas::SRSSemSelection (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSemLowDetajj"  , Lambdas::LowDEtajj       (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSemLowMjj"     , Lambdas::LowMjj          (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSemMjjIn"      , Lambdas::MjjIn           (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.getCut("SRSSemLowMjj");
        ////ana.cutflow.addCutToLastActiveCut("SRSSSideemMjjOut" , Lambdas::MjjOut          (Variation::JES, Variation::Nominal), UNITY);

        ana.cutflow.getCut("CutSRDilep");
        ana.cutflow.addCutToLastActiveCut("SRSSmm"           , Lambdas::isSRSSmmChannel                                     , UNITY);
        ana.cutflow.addCutToLastActiveCut("SRSSmmPreSel"     , Lambdas::SSPreSelection  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
        ana.cutflow.addCutToLastActiveCut("SRSSmmNj2"        , Lambdas::TwoCenJet30     (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.addCutToLastActiveCut("SRSSmmPreselMjjIn", Lambdas::MjjIn           (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.getCut("SRSSmmNj2");
        ana.cutflow.addCutToLastActiveCut("SRSSmmPreselMjjOut",Lambdas::MjjOut          (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSmmKinSel"     , Lambdas::SRSSmmSelection (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSmmLowDetajj"  , Lambdas::LowDEtajj       (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSmmLowMjj"     , Lambdas::LowMjj          (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSmmMjjIn"      , Lambdas::MjjIn           (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.getCut("SRSSmmLowMjj");
        ////ana.cutflow.addCutToLastActiveCut("SRSSSidemmMET"    , Lambdas::SRSSSidemmSel   (Variation::JES, Variation::Nominal), UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SRSSSidemmMjjOut" , Lambdas::MjjOut          (Variation::JES, Variation::Nominal), UNITY);

        ana.cutflow.getCut("CutSRTrilep");
        ana.cutflow.addCutToLastActiveCut("SR0SFOS"          , Lambdas::is0SFOS                                             , UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SR0SFOSPreSel"    , Lambdas::ThreeLepPresel  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
        ana.cutflow.addCutToLastActiveCut("SR0SFOSDYVeto"    , Lambdas::DYVetoes0SFOS                                       , UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SR0SFOSKinSel"    , Lambdas::KinSel0SFOS     (Variation::JES, Variation::Nominal), UNITY);

        ana.cutflow.getCut("CutSRTrilep");
        ana.cutflow.addCutToLastActiveCut("SR1SFOS"          , Lambdas::is1SFOS                                             , UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SR1SFOSPreSel"    , Lambdas::ThreeLepPresel  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
        ana.cutflow.addCutToLastActiveCut("SR1SFOSDYVeto"    , Lambdas::DYVetoes1SFOS                                       , UNITY);
        ana.cutflow.addCutToLastActiveCut("SR1SFOSZVeto"     , Lambdas::ZVeto3L                                             , UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SR1SFOSKinSel"    , Lambdas::KinSel1SFOS     (Variation::JES, Variation::Nominal), UNITY);

        ana.cutflow.getCut("CutSRTrilep");
        ana.cutflow.addCutToLastActiveCut("SR2SFOS"          , Lambdas::is2SFOS                                             , UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SR2SFOSPreSel"    , Lambdas::ThreeLepPresel  (Variation::JES, Variation::Nominal), Lambdas::BTagScaleFactor);
        ana.cutflow.addCutToLastActiveCut("SR2SFOSDYVeto"    , Lambdas::DYVetoes2SFOS                                       , UNITY);
        ana.cutflow.addCutToLastActiveCut("SR2SFOSZVeto"     , Lambdas::ZVeto3L                                             , UNITY);
        ////ana.cutflow.addCutToLastActiveCut("SR2SFOSKinSel"    , Lambdas::KinSel2SFOS     (Variation::JES, Variation::Nominal), UNITY);

        //************************************************************************************************************************************************************************************************
        //
        //
        // LOST LEPTON CONTROL REGIONS
        //
        //
        //************************************************************************************************************************************************************************************************

        //************************************************************************************************************************************************************************************************
        //
        //
        // APPLICATION REGIONS
        //
        //
        //************************************************************************************************************************************************************************************************

        //************************************************************************************************************************************************************************************************
        //
        //
        // N-jet 1 bin selection
        //
        //
        //************************************************************************************************************************************************************************************************

        ana.cutflow.getCut("SRSSmmPreSel");
        ana.cutflow.addCutToLastActiveCut("EXSSmmNj1OneJet" , Lambdas::OneCenJet30 (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.getCut("SRSSemPreSel");
        ana.cutflow.addCutToLastActiveCut("EXSSemNj1Channel", Lambdas::isSSem                                          , UNITY);
        ana.cutflow.addCutToLastActiveCut("EXSSemNj1OneJet" , Lambdas::OneCenJet30 (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.getCut("SRSSemPreSel");
        ana.cutflow.addCutToLastActiveCut("EXSSmeNj1Channel", Lambdas::isSSme                                          , UNITY);
        ana.cutflow.addCutToLastActiveCut("EXSSmeNj1OneJet" , Lambdas::OneCenJet30 (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.getCut("SRSSemPreSel");
        ana.cutflow.addCutToLastActiveCut("EXSSemmeNj1OneJet",Lambdas::OneCenJet30 (Variation::JES, Variation::Nominal), UNITY);
        ana.cutflow.getCut("SRSSeePreSel");
        ana.cutflow.addCutToLastActiveCut("EXSSeeNj1OneJet" , Lambdas::OneCenJet30 (Variation::JES, Variation::Nominal), UNITY);

        //************************************************************************************************************************************************************************************************
        //
        //
        // Gamma CR
        //
        //
        //************************************************************************************************************************************************************************************************

    };

    // Here I create hook for users to add various cuts and histograms of their choice to make their own studies
    // The separation between the main parts and the user_study helps to not make main analysis code too bloated
    // An example of how to add new cuts are shown in template_user_study.h
    // Copy the file template_user_study.h -> user_study.h after implementing user's additional cutflows
    // Then recompile the code and provide the option -u,--user_study as the option to the ./doAnalysis
    // OR just use process.sh script with option -u which will relay the --user_study option to the ./doAnalysis
    if (ana.do_user_study)
    {

        #if __has_include ("user_study.h")
        #include "user_study.h"
        #endif

    }
    // If --user_study option is not provided, it defaults to main analysis
    else
    {

        nominal_analysis();

    }

//*************************************************************************************************************
//
// 6. Book systematic variations
//
//*************************************************************************************************************

    // The systematics can be booked using various funcitons:
    //
    //   RooUtil::Cutflow::addCutSyst
    //   RooUtil::Cutflow::addWgtSyst
    //
    // There are two types of systematics where one only affects the weighting of each events
    // And another that affects which events passes certain cuts or not
    //
    // 1. Weight variations
    //
    //   The addWgtSyst("NameOfWgtSystUpOrDown", <lambda>);
    //
    //   The lambda is the weight that modifies the event weight (i.e. lepsf_up / lepsf) and not just the up variation weight alone (i.e. not lepsf_up alone)
    //
    // 2. Cut variations
    //
    //   This happens in two steps
    //   First, add a variation to a specific cut that gets affected by it
    //   For example, let's say
    //
    //     - SRSS*Pre, SRSS*Nj2, SRSS*LowDetajj, are affected by it.
    //
    //   then one can call, addCutSyst("JESUp", {"Pre", "Nj2", "LowDetajj", ... });
    //   too let RooUtil::Cutflow object know that there are JESUp variations for these cuts
    //   Later, when printCuts() function is called to print the cut structure user can see the booked systematic variations on the right side of the print out.
    //
    //   Then once these variations are booked to each cut, one defines them later using RooUtil::Cutflow::setCutSyst()
    //
    //   setCutSyst("SRSSmmPre", "JESUp", <lambda for cut>, <lambda for weight>);
    //

    if (ana.do_systematics)
    {
        ana.cutflow.addWgtSyst("LepSFUp"    , Lambdas::LepSFVariation     (Variation::Up   ));
        ana.cutflow.addWgtSyst("LepSFDown"  , Lambdas::LepSFVariation     (Variation::Down ));
        ana.cutflow.addWgtSyst("TrigSFUp"   , Lambdas::TriggerSFVariation (Variation::Up   ));
        ana.cutflow.addWgtSyst("TrigSFDown" , Lambdas::TriggerSFVariation (Variation::Down ));
        ana.cutflow.addWgtSyst("BTagLFUp"   , Lambdas::BTagLFVariation    (Variation::Up   ));
        ana.cutflow.addWgtSyst("BTagLFDown" , Lambdas::BTagLFVariation    (Variation::Down ));
        ana.cutflow.addWgtSyst("BTagHFUp"   , Lambdas::BTagHFVariation    (Variation::Up   ));
        ana.cutflow.addWgtSyst("BTagHFDown" , Lambdas::BTagHFVariation    (Variation::Down ));
        ana.cutflow.addWgtSyst("PileupUp"   , Lambdas::PileupVariation    (Variation::Up   ));
        ana.cutflow.addWgtSyst("PileupDown" , Lambdas::PileupVariation    (Variation::Down ));
        ana.cutflow.addWgtSyst("PDFUp"      , Lambdas::PDFVariation       (Variation::Up   ));
        ana.cutflow.addWgtSyst("PDFDown"    , Lambdas::PDFVariation       (Variation::Down ));
        ana.cutflow.addWgtSyst("QsqUp"      , Lambdas::QsqVariation       (Variation::Up   ));
        ana.cutflow.addWgtSyst("QsqDown"    , Lambdas::QsqVariation       (Variation::Down ));
        ana.cutflow.addWgtSyst("AlphaSUp"   , Lambdas::AlphaSVariation    (Variation::Up   ));
        ana.cutflow.addWgtSyst("AlphaSDown" , Lambdas::AlphaSVariation    (Variation::Down ));

        if (ana.do_fake_estimation)
        {
            ana.cutflow.addWgtSyst("FakeUp"            , Lambdas::FakeFactorVariation(Variation::Full      , Variation::Up  ));
            ana.cutflow.addWgtSyst("FakeDown"          , Lambdas::FakeFactorVariation(Variation::Full      , Variation::Down));
            ana.cutflow.addWgtSyst("FakeRateUp"        , Lambdas::FakeFactorVariation(Variation::Rate      , Variation::Up  ));
            ana.cutflow.addWgtSyst("FakeRateDown"      , Lambdas::FakeFactorVariation(Variation::Rate      , Variation::Down));
            ana.cutflow.addWgtSyst("FakeRateElUp"      , Lambdas::FakeFactorVariation(Variation::RateEl    , Variation::Up  ));
            ana.cutflow.addWgtSyst("FakeRateElDown"    , Lambdas::FakeFactorVariation(Variation::RateEl    , Variation::Down));
            ana.cutflow.addWgtSyst("FakeRateMuUp"      , Lambdas::FakeFactorVariation(Variation::RateMu    , Variation::Up  ));
            ana.cutflow.addWgtSyst("FakeRateMuDown"    , Lambdas::FakeFactorVariation(Variation::RateMu    , Variation::Down));
            ana.cutflow.addWgtSyst("FakeClosureUp"     , Lambdas::FakeFactorVariation(Variation::Closure   , Variation::Up  ));
            ana.cutflow.addWgtSyst("FakeClosureDown"   , Lambdas::FakeFactorVariation(Variation::Closure   , Variation::Down));
            ana.cutflow.addWgtSyst("FakeClosureElUp"   , Lambdas::FakeFactorVariation(Variation::ClosureEl , Variation::Up  ));
            ana.cutflow.addWgtSyst("FakeClosureElDown" , Lambdas::FakeFactorVariation(Variation::ClosureEl , Variation::Down));
            ana.cutflow.addWgtSyst("FakeClosureMuUp"   , Lambdas::FakeFactorVariation(Variation::ClosureMu , Variation::Up  ));
            ana.cutflow.addWgtSyst("FakeClosureMuDown" , Lambdas::FakeFactorVariation(Variation::ClosureMu , Variation::Down));
        }
        else
        {
            ana.cutflow.addWgtSyst("FakeUp"            , UNITY);
            ana.cutflow.addWgtSyst("FakeDown"          , UNITY);
            ana.cutflow.addWgtSyst("FakeRateUp"        , UNITY);
            ana.cutflow.addWgtSyst("FakeRateDown"      , UNITY);
            ana.cutflow.addWgtSyst("FakeRateElUp"      , UNITY);
            ana.cutflow.addWgtSyst("FakeRateElDown"    , UNITY);
            ana.cutflow.addWgtSyst("FakeRateMuUp"      , UNITY);
            ana.cutflow.addWgtSyst("FakeRateMuDown"    , UNITY);
            ana.cutflow.addWgtSyst("FakeClosureUp"     , UNITY);
            ana.cutflow.addWgtSyst("FakeClosureDown"   , UNITY);
            ana.cutflow.addWgtSyst("FakeClosureElUp"   , UNITY);
            ana.cutflow.addWgtSyst("FakeClosureElDown" , UNITY);
            ana.cutflow.addWgtSyst("FakeClosureMuUp"   , UNITY);
            ana.cutflow.addWgtSyst("FakeClosureMuDown" , UNITY);
        }

        // Declare cut varying systematics to cuts with the patterns provided in the vector
        ana.cutflow.addCutSyst("JESUp"    , {"jj", "PreSel", "Nj2", "KinSel", "SidemmMET", "OneJet", "NjLeq1", "DRljMin"});
        ana.cutflow.addCutSyst("JESDown"  , {"jj", "PreSel", "Nj2", "KinSel", "SidemmMET", "OneJet", "NjLeq1", "DRljMin"});

        // // 2016 v1.2.2 baby ntuple does not have jer variation
        // ana.cutflow.addCutSyst("JER"      , {"jj", "PreSel", "Nj", "KinSel", "SidemmMET"});
        // ana.cutflow.addCutSyst("JERUp"    , {"jj", "PreSel", "Nj", "KinSel", "SidemmMET"});
        // ana.cutflow.addCutSyst("JERDown"  , {"jj", "PreSel", "Nj", "KinSel", "SidemmMET"});

        // Lambda to add variations
        auto set_syst_cuts = [&](TString systname, Variation::ExpSyst expsyst, Variation::Var var)
        {
            ana.cutflow.setCutSyst("SRSSeePreSel"      , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("SRSSeeNj2"         , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSeeKinSel"      , systname, Lambdas::SRSSeeSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSeeLowDetajj"   , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSeeLowMjj"      , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSeeMjjIn"       , systname, Lambdas::MjjIn          (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSSideeeMjjOut"  , systname, Lambdas::MjjOut         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSemPreSel"      , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("SRSSemNj2"         , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSemKinSel"      , systname, Lambdas::SRSSemSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSemLowDetajj"   , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSemLowMjj"      , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSemMjjIn"       , systname, Lambdas::MjjIn          (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSSideemMjjOut"  , systname, Lambdas::MjjOut         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSmmPreSel"      , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("SRSSmmNj2"         , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSmmKinSel"      , systname, Lambdas::SRSSmmSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSmmLowDetajj"   , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSmmLowMjj"      , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSmmMjjIn"       , systname, Lambdas::MjjIn          (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSSidemmMET"     , systname, Lambdas::SRSSSidemmSel  (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SRSSSidemmMjjOut"  , systname, Lambdas::MjjOut         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SR0SFOSPreSel"     , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("SR0SFOSKinSel"     , systname, Lambdas::KinSel0SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SR1SFOSPreSel"     , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("SR1SFOSKinSel"     , systname, Lambdas::KinSel1SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("SR2SFOSPreSel"     , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("SR2SFOSKinSel"     , systname, Lambdas::KinSel2SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSeePreSel"    , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("WZCRSSeeNj2"       , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSeeKinSel"    , systname, Lambdas::SRSSeeSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSeeLowDetajj" , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSeeLowMjj"    , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSemPreSel"    , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("WZCRSSemNj2"       , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSemKinSel"    , systname, Lambdas::SRSSemSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSemLowDetajj" , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSemLowMjj"    , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSmmPreSel"    , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("WZCRSSmmNj2"       , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSmmKinSel"    , systname, Lambdas::SRSSmmSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSmmLowDetajj" , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCRSSmmLowMjj"    , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCR1SFOSPreSel"   , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("WZCR1SFOSKinSel"   , systname, Lambdas::KinSel1SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("WZCR2SFOSPreSel"   , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("WZCR2SFOSKinSel"   , systname, Lambdas::KinSel2SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSeePreSel"      , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("ARSSeeNj2"         , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSeeKinSel"      , systname, Lambdas::SRSSeeSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSeeLowDetajj"   , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSeeLowMjj"      , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSeeMjjIn"       , systname, Lambdas::MjjIn          (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSSideeeMjjOut"  , systname, Lambdas::MjjOut         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSemPreSel"      , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("ARSSemNj2"         , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSemKinSel"      , systname, Lambdas::SRSSemSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSemLowDetajj"   , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSemLowMjj"      , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSemMjjIn"       , systname, Lambdas::MjjIn          (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSSideemMjjOut"  , systname, Lambdas::MjjOut         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSmmPreSel"      , systname, Lambdas::SSPreSelection (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("ARSSmmNj2"         , systname, Lambdas::TwoCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSmmKinSel"      , systname, Lambdas::SRSSmmSelection(expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSmmLowDetajj"   , systname, Lambdas::LowDEtajj      (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSmmLowMjj"      , systname, Lambdas::LowMjj         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSmmMjjIn"       , systname, Lambdas::MjjIn          (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSSidemmMET"     , systname, Lambdas::SRSSSidemmSel  (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("ARSSSidemmMjjOut"  , systname, Lambdas::MjjOut         (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("AR0SFOSPreSel"     , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("AR0SFOSKinSel"     , systname, Lambdas::KinSel0SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("AR1SFOSPreSel"     , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("AR1SFOSKinSel"     , systname, Lambdas::KinSel1SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("AR2SFOSPreSel"     , systname, Lambdas::ThreeLepPresel (expsyst, var) , Lambdas::BTagScaleFactor );
            ana.cutflow.setCutSyst("AR2SFOSKinSel"     , systname, Lambdas::KinSel2SFOS    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSeeNj1OneJet"   , systname, Lambdas::OneCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSeeNj1DRljMin"  , systname, Lambdas::Nj1DRljMin     (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSemNj1OneJet"   , systname, Lambdas::OneCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSemNj1DRljMin"  , systname, Lambdas::Nj1DRljMin     (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSmeNj1OneJet"   , systname, Lambdas::OneCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSmeNj1DRljMin"  , systname, Lambdas::Nj1DRljMin     (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSmmNj1OneJet"   , systname, Lambdas::OneCenJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXSSmmNj1DRljMin"  , systname, Lambdas::Nj1DRljMin     (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSeeNjLeq1"    , systname, Lambdas::LeqOneJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSeeNj1KinSel" , systname, Lambdas::Nj1CRKinSel    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSemNjLeq1"    , systname, Lambdas::LeqOneJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSemNj1KinSel" , systname, Lambdas::Nj1CRKinSel    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSmeNjLeq1"    , systname, Lambdas::LeqOneJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSmeNj1KinSel" , systname, Lambdas::Nj1CRKinSel    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSmmNjLeq1"    , systname, Lambdas::LeqOneJet30    (expsyst, var) , UNITY                    );
            ana.cutflow.setCutSyst("EXCRSSmmNj1KinSel" , systname, Lambdas::Nj1CRKinSel    (expsyst, var) , UNITY                    );
        };

        // Actually set the door
        set_syst_cuts("JESUp", Variation::JES, Variation::Up);
        set_syst_cuts("JESDown", Variation::JES, Variation::Down);

        // // If newer year also set JER
        // set_syst_cuts("JER", Variation::JER, Variation::Nominal);
        // set_syst_cuts("JERUp", Variation::JER, Variation::Up);
        // set_syst_cuts("JERDown", Variation::JER, Variation::Down);

    }



//*************************************************************************************************************
//
// 7. Booking histograms and cutflows
//
//*************************************************************************************************************

    // So far we have defined a tree structure of cuts (RooUtil::Cutflow object)
    // Also we defined a list of histograms (RooUtil::Histograms)

    // Now we need to book the histograms for cutflows and variable distribution histograms
    // So during the loop it actually fills them

    // First of all, if the ana.do_systematics == true, we are not going to run all cutflows, nor all histograms
    // We will only run histograms at the very end of the cuts, this is to speed things up

    // NOTE: Booking cutflows generally take longer than booking a lot of histograms only at the end cut level
    // I haven't fully understood why. I think it might be due to the map look up time. (TString EqualTo calls)

    // If --force was provided skip this special if statement and go to else statement and do things normally
    if (ana.do_systematics and not ana.do_force)
    {
        // Book histograms only at the end cuts
        ana.cutflow.bookHistogramsForEndCuts(ana.histograms);

        // And NO book cutflows!
    }
    else
    {

        // Book histograms
        if (ana.do_histograms)
        {
            ana.cutflow.bookHistogramsForCutAndBelow(ana.histograms, "CutSRDilep");
            ana.cutflow.bookHistogramsForCutAndBelow(ana.histograms, "CutSRTrilep");
        }

        // Book cutflows
        if (ana.do_cutflow)
            ana.cutflow.bookCutflows();

    }

    //
    // Print cut structure before starting the loop just to visually see it
    //
    // Print once before starting any loop (at this point, "pass|weight" columns will be entirely empty since it's not showing for a any specific event
    ana.cutflow.printCuts();

    //
    // The following function will print out the tree structure for example
    //
    // RooUtil::Cutflow::printCuts();
    //
    // <Program is running>
    // ...
    // ...
    // ...
    // RooUtil:: Cut name                                                     |pass|weight|systs
    // RooUtil:: ======================================================================================
    // RooUtil:: Root                                                         | 0 | 0.000000|
    // RooUtil::   CutWeight                                                  | 0 | 0.000000|
    // RooUtil::     CutPreliminary                                           | 0 | 0.000000|
    // RooUtil::       CutTrigger                                             | 0 | 0.000000|
    // RooUtil::        +CutSRDilep                                           | 0 | 0.000000|
    // RooUtil::        | +SRSSmm                                             | 0 | 0.000000|
    // RooUtil::        | |  SRSSmmTVeto                                      | 0 | 0.000000|
    // RooUtil::        | |    SRSSmmNj2                                      | 0 | 0.000000|
    // RooUtil::        | |      SRSSmmNb0                                    | 0 | 0.000000|
    // RooUtil::        | |        SRSSmmMjjW                                 | 0 | 0.000000|
    // RooUtil::        | |          SRSSmmMjjL                               | 0 | 0.000000|
    // RooUtil::        | |            SRSSmmDetajjL                          | 0 | 0.000000|
    // RooUtil::        | |              SRSSmmMET                            | 0 | 0.000000|
    // RooUtil::        | |                SRSSmmMllSS                        | 0 | 0.000000|
    // RooUtil::        | |                  SRSSmmFull                       | 0 | 0.000000|
    // RooUtil::        | +SRSSem                                             | 0 | 0.000000|
    // RooUtil::        | |  SRSSemTVeto                                      | 0 | 0.000000|
    // RooUtil::        | |    SRSSemNj2                                      | 0 | 0.000000|
    // RooUtil::        | |      SRSSemNb0                                    | 0 | 0.000000|
    // RooUtil::        | |        SRSSemMjjW                                 | 0 | 0.000000|
    // RooUtil::        | |          SRSSemMjjL                               | 0 | 0.000000|
    // RooUtil::        | |            SRSSemDetajjL                          | 0 | 0.000000|
    // RooUtil::        | |              SRSSemMET                            | 0 | 0.000000|
    // RooUtil::        | |                SRSSemMllSS                        | 0 | 0.000000|
    // RooUtil::        | |                  SRSSemMTmax                      | 0 | 0.000000|
    // RooUtil::        | |                    SRSSemFull                     | 0 | 0.000000|
    // RooUtil::        | +SRSSee                                             | 0 | 0.000000|
    // RooUtil::        | |  SRSSeeZeeVt                                      | 0 | 0.000000|
    // RooUtil::        | |    SRSSeeTVeto                                    | 0 | 0.000000|
    // RooUtil::        | |      SRSSeeNj2                                    | 0 | 0.000000|
    // RooUtil::        | |        SRSSeeNb0                                  | 0 | 0.000000|
    // RooUtil::        | |          SRSSeeMjjW                               | 0 | 0.000000|
    // RooUtil::        | |            SRSSeeMjjL                             | 0 | 0.000000|
    // RooUtil::        | |              SRSSeeDetajjL                        | 0 | 0.000000|
    // RooUtil::        | |                SRSSeeMET                          | 0 | 0.000000|
    // RooUtil::        | |                  SRSSeeMllSS                      | 0 | 0.000000|
    // RooUtil::        | |                    SRSSeeFull                     | 0 | 0.000000|
    // ...
    // ...
    // ...
    //
    // (note, the above printout was from an older version of the code, so the cut structure changed a little bit)
    //
    // Also, for debugging purpose, one could print this per event.
    // If printCuts() is called AFTER "RooUtil::Cutflow::fill()" is called,
    // Then, the "pass|weight" columns on the right will be filled with whether at certain cut stage event passes or not.
    // along with event weights
    //

//*************************************************************************************************************
//
// 8. Looping events
//
//*************************************************************************************************************

    while (ana.looper.nextEvent())
    {

        // If a new file was opened after "looper.nextEvent" was called configure the sample dependent settings in class InputConfig;
        if (ana.looper.isNewFileInChain())
        {
            input.determine_input_settings(ana.looper.getCurrentFileName(), ana.input_tree_name);
        }

        // If splitting jobs are requested then determine whether to process the event or not based on remainder
        if (result.count("job_index") and result.count("nsplit_jobs"))
        {
            if (ana.looper.getNEventsProcessed() % ana.nsplit_jobs != (unsigned int) ana.job_index)
                continue;
        }

        // // For memoize function. This is to cache results for each event. this_run/lumi/evt is a global variable defined in lambdas.cc
        // this_run = www.run();
        // this_lumi = www.lumi();
        // this_evt = www.evt();

        // // Theory related weights from h_neventsinfile in each input root file but only set files when new file opens
        // // NOTE if there was a continue statement prior to this it can mess it up
        // if (looper.isNewFileInChain() and not isData) theoryweight.setFile(looper.getCurrentFileName());

        // // Set the event list variables
        // cutflow.setEventID(www.run(), www.lumi(), www.evt());

        // This magic "fill()" function will now go through all the cut nodes in the RooUtil::Cutflow and evaluate whether it passes the cut or not
        // And also fill histograms for all the booked histograms and fill all the book cutflows
        ana.cutflow.fill();

        // if (ana.cutflow.getCut("SRSSmmFull").pass)
        // {
        //     std::cout << std::endl;
            // std::cout <<  " www.run(): " << www.run() <<  " www.lumi(): " << www.lumi() <<  " www.evt(): " << www.evt() <<  std::endl;
            // std::cout <<  " www.CMS4path(): " << www.CMS4path() <<  " www.CMS4index(): " << www.CMS4index() <<  std::endl;
            // std::cout <<  " Lambdas::EventWeight(): " << Lambdas::EventWeight() <<  std::endl;
            // std::cout <<  " www.lep_pdgId()[0]: " << www.lep_pdgId()[0] <<  " www.lep_pdgId()[1]: " << www.lep_pdgId()[1] <<  std::endl;
            // std::cout <<  " www.lep_motherIdSS()[0]: " << www.lep_motherIdSS()[0] <<  " www.lep_motherIdSS()[1]: " << www.lep_motherIdSS()[1] <<  std::endl;
            // std::cout <<  " www.lep_convVeto()[0]: " << www.lep_convVeto()[0] <<  " www.lep_convVeto()[1]: " << www.lep_convVeto()[1] <<  std::endl;
            // std::cout <<  " www.lep_lostHits()[0]: " << www.lep_lostHits()[0] <<  " www.lep_lostHits()[1]: " << www.lep_lostHits()[1] <<  std::endl;

#ifdef WITHCORE
            // cms4reader.open();
            // cms4reader.printLeptons();
            // cms4reader.printPartonsWithCondition("===All Particles===");
#endif

        // }

        // if (ana.cutflow.getCut("SRSSmmFull").pass || ana.cutflow.getCut("SRSSemFull").pass || ana.cutflow.getCut("SRSSeeFull").pass)
        // {
        //     std::cout <<  " www.lep_pdgId()[0]: " << www.lep_pdgId()[0] <<  " www.lep_pdgId()[1]: " << www.lep_pdgId()[1] <<  std::endl;
        //     std::cout <<  " www.lep_motherIdSS()[0]: " << www.lep_motherIdSS()[0] <<  " www.lep_motherIdSS()[1]: " << www.lep_motherIdSS()[1] <<  std::endl;
        //     std::cout <<  " www.lep_convVeto()[0]: " << www.lep_convVeto()[0] <<  " www.lep_convVeto()[1]: " << www.lep_convVeto()[1] <<  std::endl;
        //     std::cout <<  " www.lep_lostHits()[0]: " << www.lep_lostHits()[0] <<  " www.lep_lostHits()[1]: " << www.lep_lostHits()[1] <<  std::endl;
        // }

        // // Must come after .fill() so that the cuts are all evaulated
        // if (eventlist.has(www.run(), www.lumi(), www.evt()))
        // {
        //     std::cout <<  "***************************" << std::endl;
        //     std::cout <<  "**** Cutflow Challenge ****" << std::endl;
        //     std::cout <<  "***************************" << std::endl;
        //     std::cout <<  " Checking following events:" << std::endl;
        //     std::cout <<  " www.run(): " << www.run() <<  " www.lumi(): " << www.lumi() <<  " www.evt(): " << www.evt() <<  std::endl;
        //     std::cout <<  " Below shows whether it passes or fails the cuts" << std::endl;
        //     cutflow.printCuts();
        // }

        // if (ana.cutflow.getCut("SRSSmmFull").pass)
        // {

        //     float pt0 = www.lep_p4()[0].pt();
        //     float pt1 = www.lep_p4()[1].pt();
        //     float eta0 = www.lep_p4()[0].eta();
        //     float eta1 = www.lep_p4()[1].eta();
        //     float leadeta  = std::min(fabs(eta0), (float)2.39);
        //     float traileta = std::min(fabs(eta1), (float)2.39);
        //     float leadpt   = std::min(pt0, (float)199.);
        //     float trailpt  = std::min(pt1, (float)199.);

        //     float bigeta   = leadeta > traileta ? leadeta  : traileta;
        //     float smalleta = leadeta > traileta ? traileta : leadeta;

        //     // is mm events
        //     if (abs(www.lep_pdgId()[0]) == 13 && abs(www.lep_pdgId()[1]) == 13)
        //     {
        //         // related to lepton legs
        //         float e_l0 = trigsf_mu_lead(leadpt, leadeta);
        //         float e_t1 = trigsf_mu_trail(trailpt, traileta);
        //         float d_l0 = trigsf_mu_lead(leadpt, leadeta, 1) - trigsf_mu_lead(leadpt, leadeta);
        //         float d_t1 = trigsf_mu_trail(trailpt, traileta, 1) - trigsf_mu_trail(trailpt, traileta);
        //         float tempeff = 1.0;
        //         float temperr = 0.0;
        //         std::tie(tempeff, temperr) = getCombinedTrigEffandError(e_l0, 0., 0., e_t1, d_l0, 0., 0., d_t1);
        //         // dz
        //         float dzeff = 0.241 * trigsf_dimu_dz(smalleta, bigeta) + (1 - 0.241) * 1; // Because DZ filter only affects Period H
        //         float dzerr = 0.241 * (trigsf_dimu_dz(smalleta, bigeta, 1) - trigsf_dimu_dz(smalleta, bigeta));
        //         float eff = tempeff * dzeff;
        //         float err = eff * sqrt(pow(temperr / tempeff, 2) + pow(dzerr / dzeff, 2));
        //         // And the fractino of period H is calculated from here: http://www.t2.ucsd.edu/tastwiki/bin/view/CMS/Run2_Data2016
        //         // 8.636 + 0.221 / 36.814 = 0.241

        //         std::cout <<  " tempeff: " << tempeff <<  " temperr: " << temperr <<  std::endl;
        //         std::cout <<  " dzeff: " << dzeff <<  " dzerr: " << dzerr <<  std::endl;
        //         std::cout <<  " eff: " << eff <<  " err: " << err <<  std::endl;
        //         std::cout <<  " (eff+err)/eff: " << (eff+err)/eff <<  " (eff-err)/eff: " << (eff-err)/eff <<  std::endl;

        //         std::cout <<  " www.lep_p4()[0].pt(): " << www.lep_p4()[0].pt() <<  " www.lep_p4()[0].eta(): " << www.lep_p4()[0].eta() <<  " www.lep_pdgId()[0]: " << www.lep_pdgId()[0] <<  std::endl;
        //         std::cout <<  " www.lep_p4()[1].pt(): " << www.lep_p4()[1].pt() <<  " www.lep_p4()[1].eta(): " << www.lep_p4()[1].eta() <<  " www.lep_pdgId()[1]: " << www.lep_pdgId()[1] <<  std::endl;
        //         float trigsf = Lambdas::TriggerScaleFactor();
        //         float trigsfup = Lambdas::TriggerSFVariation(Variation::Up)();
        //         float trigsfdn = Lambdas::TriggerSFVariation(Variation::Down)();
        //         std::cout <<  " trigsf: " << trigsf <<  " trigsfup: " << trigsfup <<  " trigsfdn: " << trigsfdn <<  std::endl;

        //     }
        // }

    }

    // Once done with the loop, now save all the histograms to the output file
    ana.cutflow.saveOutput();

}

